package {	import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.geom.Matrix;	import flash.display.Bitmap;	import com.adobe.images.*;	import nochump.util.zip.*;	import flash.utils.*;	import com.edgarcai.utils.bitmapdataUtil;	import flash.net.FileReference;	import flash.geom.Point;	public class mainDoc extends MovieClip	{		private var msg:String = "";		private var _serialMap:Array = new Array();		private var _mcArray:Array = new Array();		private var _maxWid:Number = 0;		private var _maxHei:Number = 0;		public function mainDoc()		{			trace(">>>>movieclip to bitmapdata");			var i, j:int;			var _singleMC:Array = new Array();			for (i=0; i< this.numChildren; i++)			{				_singleMC = getMovieBitData(this.getChildAt(i) as MovieClip);				_serialMap.push(_singleMC);				_mcArray.push(this.getChildAt(i) as MovieClip);			}			//删除舞台上元件			while (this.numChildren) 			{                this.removeChildAt(0);			}			trace(">>>>convert finsih \n>>>>start calc maxwidth and max height");						var _resultData:Object = getframesMaxSize(_serialMap);			var _mcResult:Object = getmcMaxSize(_mcArray);						if (_resultData.width < _mcResult.width)			{				_maxWid = Math.ceil(_mcResult.width);				msg += ">>>>最大宽度为" + _maxWid + ",元件名为" + _mcArray[_mcResult.widmcindex].name + "\n";				trace(">>>>最大宽度为" + _maxWid + ",元件名为" + _mcArray[_mcResult.widmcindex].name);			}else {				_maxWid = Math.ceil(_resultData.width);				msg += ">>>>最大宽度为"+_maxWid+",元件名为"+_serialMap[_resultData.widmcindex][_resultData.widframeindex].name+"\n";				trace(">>>>最大宽度为"+_maxWid+",元件名为"+_serialMap[_resultData.widmcindex][_resultData.widframeindex].name);			}			//对比frames与mc的最大宽高			if (_resultData.height < _mcResult.height)			{				_maxHei = Math.ceil(_mcResult.height);				msg += ">>>>最大高度为" + _maxHei + ",元件名为" + _mcArray[_mcResult.heimcindex].name + "\n";				trace(">>>>最大高度为" + _maxHei + ",元件名为" + _mcArray[_mcResult.heimcindex].name);			}else {				_maxHei = Math.ceil(_resultData.height);				msg+= ">>>>最大高度为"+_maxHei+",元件名为"+_serialMap[_resultData.heimcindex][_resultData.heiframeindex].name+"\n";				trace(">>>>最大高度为"+_maxHei+",元件名为"+_serialMap[_resultData.heimcindex][_resultData.heiframeindex].name);			}						//test			_maxWid = Math.ceil(_maxWid);			_maxHei = Math.ceil(_maxHei);			//test end						trace("开始导图");			var holderSpr:Sprite = new Sprite();			holderSpr.width = _maxWid;			holderSpr.height = _maxHei;			holderSpr.x = holderSpr.y = 0;			this.addChild(holderSpr);			for (i = 0; i < _mcArray.length; i++ )			{				while (holderSpr.numChildren) 				{					holderSpr.removeChildAt(0);				}				var item:MovieClip = _mcArray[i];				item.x = item.y = 0;				holderSpr.addChild(item);				item.gotoAndStop(1);				for (j = 0; j < item.totalFrames; j++)				{					var rect:Rectangle = holderSpr.getBounds(holderSpr);					var matrix:Matrix = new Matrix(1,0,0,1, -  rect.x, -  rect.y);					var bitData:BitmapData = new BitmapData(_maxWid,_maxHei,true,0);					bitData.draw(holderSpr, matrix);					_serialMap[i][j].bitmapdata = bitData;					_serialMap[i][j].wid = _maxWid;					_serialMap[i][j].hei = _maxHei;					_serialMap[i][j].rect = rect;					item.nextFrame();				}			}						var max:uint = _serialMap.length;			var _fzip:ZipOutput = new ZipOutput();			var _txtBytes:ByteArray = new ByteArray();			var _ind:int = 0;			var _realSerialMap:Array = new Array();			for (var bitstep:uint =0; bitstep<_serialMap.length; bitstep++)			{				for (var metastep:int =0; metastep<_serialMap[bitstep].length; metastep++)				{					var filename:String = _serialMap[bitstep][metastep].name + ".png";					trace("filename:"+filename);					var entry:ZipEntry = new ZipEntry(filename);					_fzip.putNextEntry(entry);					var _realbitmapdata:BitmapData = new BitmapData(_maxWid,_maxHei,true,0);					//var destpoint:Point = new Point(_maxWid-_serialMap[bitstep][metastep].wid,_maxHei-_serialMap[bitstep][metastep].hei);					//_realbitmapdata.copyPixels(_serialMap[bitstep][metastep].bitmapdata,_serialMap[bitstep][metastep].rect,destpoint);					var m:Matrix = new Matrix();					var maxrect:Rectangle =new Rectangle(0,0,_maxWid,_maxHei);					m.translate(-maxrect.x,-maxrect.y);					_realbitmapdata.draw(_serialMap[bitstep][metastep].bitmapdata,m);					_realSerialMap.push(_realbitmapdata);					var _byte:ByteArray = PNGEncoder.encode(_realbitmapdata);					_fzip.write(_byte);					_fzip.closeEntry();					msg += "\n id="+(_ind+1)					+" name:"+filename					+" size:"+_serialMap[bitstep][metastep].wid					+","+_serialMap[bitstep][metastep].hei;					_ind++;					trace(">>>>>>>>导图进度："+_ind);				}			}			//配置文件;			if (msg!="")			{				_txtBytes.writeUTFBytes(msg);				var txtentry:ZipEntry = new ZipEntry("config.txt");				_fzip.putNextEntry(txtentry);				_fzip.write(_txtBytes);				_fzip.closeEntry();			}						//拼成大图			var bigmap:BitmapData = bitmapdataUtil.concatBitmapDataLimitWidth(_realSerialMap,_maxWid * 6);			var bigentry:ZipEntry = new ZipEntry("bigmap.png");			_fzip.putNextEntry(bigentry);			var _bigbyte:ByteArray = PNGEncoder.encode(bigmap);			_fzip.write(_bigbyte);			_fzip.closeEntry();						if (_fzip.size > 0)			{				_fzip.finish();			}			var files:FileReference = new FileReference();			files.save(_fzip.byteArray,"pngs.zip");		}				//返回movieclip数组的最大宽高		private function getmcMaxSize(mcArray:Array):Object		{			var result:Object = new Object();			result.width = mcArray[0].width;			result.height = mcArray[0].height;			result.widmcindex = 0;			result.heimcindex = 0;			for (var i:int = 0; i < mcArray.length; i++ )			{				if (result.width < mcArray[i].width)				{					result.width = mcArray[i].width;					result.widmcindex = i;				}				if (result.height < mcArray[i].height)				{					result.height = mcArray[i].height;					result.heimcindex = i;				}			}			return result;		}		//返回规定数组最大宽高		private function getframesMaxSize(framesArray:Array):Object		{			var result:Object = new Object();			result.width = framesArray[0][0].wid;			result.height = framesArray[0][0].hei;			result.widmcindex = 0;			result.widframeindex = 0;			result.heimcindex = 0;			result.heiframeindex = 0;			for (var i:uint =0; i<framesArray.length; i++)			{				for (var j:int =0; j< framesArray[i].length; j++)				{					if (result.width < framesArray[i][j].wid)					{						result.width = framesArray[i][j].wid;						result.widmcindex = i;						result.widframeindex = j;					}					if (result.height < framesArray[i][j].hei)					{						result.height = framesArray[i][j].hei;						result.heimcindex = i;						result.heiframeindex = j;					}				}			}			return result;		}		//获得Mc的所有位图数据		public function getMovieBitData(mc:MovieClip):Array		{			var w:Number = 0;			var h:Number = 0;			var bitData:BitmapData;			var rect:Rectangle;			var matrix:Matrix;			var arr:Array = [];			for (var i:int,l:int = mc.totalFrames; i<l; i++)			{				rect = mc.getBounds(mc);				/*w = rect.width;				h = rect.height;*/								//test				w = Math.ceil(rect.width);				h = Math.ceil(rect.height);				//test end								trace("mc.getbounds(mc) size:"+w+","+h);				matrix = new Matrix(1,0,0,1, -  rect.x, -  rect.y);				bitData = new BitmapData(w,h,true,0);				bitData.draw(mc,matrix);				var _single:Object = new Object();				_single.bitmapdata = bitData;				_single.name = mc.name + "_" + i;				_single.wid = w;				_single.hei = h;				_single.rect = bitData.rect;				arr.push(_single);				mc.nextFrame();			}			return arr;		}	}}